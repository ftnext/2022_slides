アンパック演算子としての ``*``, ``**``
============================================================

2つのアンパック演算子
--------------------------------------------------

* イテラブルアンパック演算子
* 辞書アンパック演算子

用語は「`What's New In Python 3.5 <https://docs.python.org/ja/3/whatsnew/3.5.html#pep-448-additional-unpacking-generalizations>`_」より

イテラブルアンパック演算子 ``*``
============================================================

イテラブルとは（`用語集 <https://docs.python.org/ja/3/glossary.html#term-iterable>`_ より）
----------------------------------------------------------------------------------------------------

    要素を一度に 1 つずつ返せるオブジェクト

「反復可能オブジェクト」

これらがイテラブル（用語集より）
--------------------------------------------------

* シーケンス（リスト、文字列、タプルなど）
* 辞書
* ファイルオブジェクト
* など（※自作もできます）

イテラブルアンパック演算子を使ってみる
--------------------------------------------------

.. code-block:: python

    >>> # タプル (1, 2) は（シーケンスであり）イテラブル
    >>> [*(1, 2)]
    [1, 2]

タプルと同じ要素を持つリストを作る方法の1つ

イテラブルアンパック演算子で新しいリストを作る
--------------------------------------------------

.. code-block:: python

    >>> [*(1, 2), 3]
    [1, 2, 3]

他のイテラブルでも新しいリスト作り
--------------------------------------------------

.. code-block:: python

    >>> [0, *[1, 2]]
    [0, 1, 2]
    >>> [*range(2), 2]
    [0, 1, 2]
    >>> [*"12", 3]
    ['1', '2', 3]

新しいタプルも作れます
--------------------------------------------------

.. code-block:: python

    >>> (*(1, 2), 3)
    (1, 2, 3)

ご存知ですか？ タプルの肝は **カンマ**
--------------------------------------------------

    タプルを書くときは必ずしも丸括弧で囲まなくてもいい （`Pythonチュートリアル 5.3. <https://docs.python.org/ja/3/tutorial/datastructures.html#tuples-and-sequences>`_）

.. code-block:: python

    >>> 1, 2
    (1, 2)
    >>> 1,
    (1,)

カッコつけずに書けます
--------------------------------------------------

.. code-block:: python

    >>> *(1, 2), 3  # (*(1, 2), 3) をカッコつけずに
    (1, 2, 3)
    >>> *(1, 2),  # (*(1, 2),) をカッコつけずに
    (1, 2)
    >>> *(1, 2)  # doctest: +SKIP
      File "<stdin>", line 1
    SyntaxError: can't use starred expression here

辞書をイテラブルアンパック演算子に渡すと
------------------------------------------------------------

.. code-block:: python

    >>> # 辞書はイテラブル
    >>> fruits_prices = {"apple": 100, "banana": 50}
    >>> *fruits_prices,
    ('apple', 'banana')

**キー** が取り出されます

辞書アンパック演算子 ``**``
============================================================

辞書アンパック演算子を使ってみる
--------------------------------------------------

.. code-block:: python

    >>> fruits_prices = {"apple": 100, "banana": 50}
    >>> {**fruits_prices}
    {'apple': 100, 'banana': 50}

新しい辞書を作れます
--------------------------------------------------

.. code-block:: python

    >>> {**fruits_prices, "melon": 777}
    {'apple': 100, 'banana': 50, 'melon': 777}
    >>> {"melon": 777, **fruits_prices}
    {'melon': 777, 'apple': 100, 'banana': 50}

キーと値の組を **追加** した辞書

アンパック演算子は複数使える！
============================================================

* Python 3.5から可能になりました
* `PEP 448 – Additional Unpacking Generalizations <https://peps.python.org/pep-0448/>`_

アンパック演算子を複数使う例
--------------------------------------------------

.. code-block:: python

    >>> [*(1, 2), 3, *range(2)]
    [1, 2, 3, 0, 1]

    >>> d1, d2 = {"x": 11, "y": 22}, {"v": 101, "w": 201}
    >>> {**d1, "z": -33, **d2}
    {'x': 11, 'y': 22, 'z': -33, 'v': 101, 'w': 201}

2つの辞書をマージして新しい辞書を作りたい
--------------------------------------------------

* 「forで回しているマージしているんですけど、もっとシュッと書けないですかね？」
* 💡それ、辞書アンパック演算子でできます！！

.. revealjs-break::

.. code-block:: python

    >>> d1, d2 = {"x": 11, "y": 22}, {"v": 101, "y": -22}
    >>> {**d1, **d2}  # キーが重複したら後勝ち
    {'x': 11, 'y': -22, 'v': 101}

プロポーザルの「私は先日2つの辞書のマージが ``*`` でスッキリ書けました」回収✌️

まとめ🥟：アンパック演算子としての ``*``, ``**``
============================================================

* イテラブルアンパック演算子 ``*`` を使って新しいリストやタプルを作れる
* 辞書アンパック演算子 ``**`` を使って新しい辞書を作れる
* 複数使える！（PEP 448）
