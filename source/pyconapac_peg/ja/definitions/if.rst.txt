``if`` 文
========================================

    if 文は、条件分岐を実行するために使われます:

`8.1. if 文 <https://docs.python.org/ja/3/reference/compound_stmts.html#the-if-statement>`_

.. if 文は、条件分岐を実行するために使われると記載されていますし、実際私たちもそういうふうに使います

``if`` 文の構文を（PEGを使わずに）どう伝えますか❔
----------------------------------------------------------

少し考えてみてください

.. ここで質問なのですが、if文の構文をPEGを使わずにどう伝えるか、ちょっと考えてみてください
    ＜少し間＞
    この後は私だったらこうするという紹介と実際PEGでどう定義されているかを見ていきます。
    ＜10秒程度＞
    考えはまとまりましたか？

私の戦略：場合分け
------------------------------------------------

* elseの有無

  * ``if ...``
  * ``if ... else ...``

.. 私が説明するとしたら徹底的に場合分けするかなと思っています。
    まずelseの有無で if だけのときと、if else のときがありますよねと分けます

場合分け、抜け漏れの確認ツライ😫
------------------------------------------------

* elifの個数（0個／1個／複数）

  * ``if ... elif ...``
  * ``if ... elif ... elif ...``
  * ``if ... elif ... else ...``
  * ``if ... elif ... elif ... else ...``

.. 次にelifで場合分けしていきますが、抜け漏れがないように網羅するのが辛かったです。
    elifが0個の場合はすでに見ています。
    elifが1個だけ、elifが2個以上、elif1個とelse、elif2個以上とelseの場合と分けました。

PEGでは、こう
------------------------------------------------

.. literalinclude:: grammar/if.gram
    :language: peg

.. PEGでの記載はこのようになります。
    これを一緒に読み解いていきましょう。
    ここでblockというのが何回か出てきますが、

``block`` とは
------------------------------------------------

.. code-block:: peg

    block:
        | NEWLINE INDENT statements DEDENT
        | simple_stmts

.. blockとは何かを簡単に言うと

``block`` の構成要素
------------------------------------------------

.. code-block:: peg

    statements: statement+
    statement: compound_stmt  | simple_stmts
    # simple_stmtsを手短に言うと、複数のsimple_stmt

.. statements、つまり1つ以上のstatementから構成されていて、
    statementは複合文、または複数の単純文からなります

``block``
------------------------------------------------

.. code-block:: peg

    # 改行しインデントされた複数の文（単純文でも複合文でもよい）、
    # または、改行せず続く複数の単純文
    block:
        | NEWLINE INDENT statements DEDENT
        | simple_stmts

.. なのでblockとは、改行しインデントされた複数の文だったり
    改行せず続く複数の単純文だったりします。

味わう ``if`` 文 1/2
------------------------------------------------

.. literalinclude:: grammar/if.gram
    :language: peg
    :lines: 1-3

* キーワード ``if`` で始まるヘッダと続くブロックからなる節は **必須**
* ``if`` の後に、 **elifの有無** で考えている

.. if文の規則のうちif_stmtを見ていくと、キーワードifで始まるヘッダと続くブロックからなる節が必須
    ifの後にelifがあるかないかで考えていることが分かります

味わう ``if`` 文 2/2
------------------------------------------------

.. literalinclude:: grammar/if.gram
    :language: peg
    :lines: 4-6

* ``elif`` の後に、``elif`` がさらに続くときと続かないとき

.. elif_stmtを見ていくと、elifで始まるヘッダと定義されていますが、
    ポイントは ``elif`` がさらに続くか続かないかとしている点だと思います

PEGで表した ``if`` 文
------------------------------------------------

* ``if`` 節は必須
* **elif節の有無** に着目している！
* ``else`` 節はオプショナル扱い（``[]``）
* この考え方で抜け漏れがない！

.. まとめると、ifは必須。
    elifがあるかないかに着目して書き下していて
    elseはオプショナル。
    これは単純で抜け漏れなく捉えられているなと自分の場合分けの説明と比較して感動しました

脱線： ``named_expression``
========================================

``if`` 節や ``elif`` 節のヘッダに登場する ``named_expression`` について

.. ここで named_expression に脱線するんですけれど

``named_expression``
------------------------------------------------

.. code-block:: peg

    # 代入式、または（代入式でない）式
    named_expression:
        | assignment_expression
        | expression !':='

    assignment_expression:
        | NAME ':=' ~ expression

.. named_expressionは代入式、または代入式でない式と定義されています（否定先読みですね）

代入式はPython 3.8 (2019/10 release) から
------------------------------------------------

    大きな構文の一部として、変数に値を割り当てる新しい構文 := が追加されました。
    この構文は セイウチの目と牙 に似ているため、「セイウチ演算子」の愛称で知られています。

https://docs.python.org/ja/3/whatsnew/3.8.html#assignment-expressions

.. 代入式はPython 3.8から導入された機能でして、変数に値を割り当てる新しい構文 colon equal
    これはセイウチ演算子とも呼ばれます。ちなみに読みはウォルラスらしいです
    （ソースはEffective Python）

代入式の例（Python 3.8 What's Newより）
------------------------------------------------

    代入式により len() 関数を二重に呼びだすことを回避しています:

.. code-block:: python

    if (n := len(a)) > 10:
        print(f"List is too long ({n} elements, expected <= 10)")

.. 代入式の例なんですけど、代入式により len() 関数を二重に呼びだすことを回避している
    n := len(a)でnにlen(a)が代入されます。
    len(a)が15であればnに代入されているので、len(a)は2回呼ばなくて済んでいます

.. ✍️ この例のパースは group gt_bitwise_or
    https://scrapbox.io/nikkie-memos/named_expression%E3%82%92%E3%83%91%E3%83%BC%E3%82%B9%E3%81%99%E3%82%8B%E4%BE%8B

``named_expression`` の構文を読んで
------------------------------------------------

* 代入式 ``:=`` は制御フローの構文を変えるほどの **大きな変更** と気づいた
* ``if`` 文のほか、 ``while`` 文の定義にも登場します

.. この構文を読んでみると
    代入式は制御フローの構文に影響するほどの **大きな変更** だったんだなあという気付きがありました
    （これまでは使う側だったので気にしていなかった）
    なお、named_expressionという規則はwhile文でも登場します
